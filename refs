--> locals
local LocalPlayer = cloneref(game:GetService("Players").LocalPlayer)
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local Workspace = cloneref(game:GetService("Workspace"))
local Camera = Workspace.CurrentCamera
local WorldToViewportPoint = Camera.WorldToViewportPoint
local RunService = cloneref(game:GetService("RunService"))
local TweenService = cloneref(game:GetService("TweenService"))
local Coregui = gethui() or cloneref(game:GetService("CoreGui"))
local gui = Instance.new("ScreenGui", Coregui)

while not game:IsLoaded() do task.wait() end

local Classes = {
	["PlayerClient"] = {},
	["Character"] = {},
	["BowClient"] = {},
	["Camera"] = {},
	["RangedWeaponClient"] = {},
	["GetEquippedItem"] = {},
	["FPS"] = {},
}

for _, v in pairs(getgc(true)) do
	if typeof(v) == "function" and islclosure(v) then
		local info = debug.getinfo(v)
		local name = string.match(info.short_src, "%.([%w_]+)$")
		if name and Classes[name] and info.name ~= nil then
			Classes[name][info.name] = info.func
		end
	end
end

local Players = debug.getupvalue(Classes.PlayerClient.updatePlayers, 1)



function GetBoundingBox(Model)
	local cf, size = Model:GetBoundingBox()
	local halfSizeX, halfSizeY, halfSizeZ = size.X / 2, size.Y / 2, size.Z / 2

	local left, right = math.huge, -math.huge
	local top, bottom = math.huge, -math.huge

	for _, xSign in ipairs({1, -1}) do
		for _, ySign in ipairs({1, -1}) do
			for _, zSign in ipairs({1, -1}) do
				local corner = cf * CFrame.new(halfSizeX * xSign, halfSizeY * ySign, halfSizeZ * zSign)
				local screenPos, onScreen = Camera:WorldToScreenPoint(corner.Position)

				if onScreen then
					left = math.min(left, screenPos.X)
					right = math.max(right, screenPos.X)
					top = math.min(top, screenPos.Y)
					bottom = math.max(bottom, screenPos.Y)
				end
			end
		end
	end

	return math.floor(left), math.floor(right), math.floor(top), math.floor(bottom), size
end


local cache = {}
local HasEsp = {}
function CreateEsp(playertable)
	if not playertable then return end
	local drawings = {}
	drawings.innerline = Instance.new("Frame", gui);drawings.innerline.Visible = false;drawings.innerline.Transparency = 1;drawings.innerline.ZIndex = 9999;
	drawings.outerline = Instance.new("Frame", drawings.innerline);drawings.outerline.Visible = false;drawings.outerline.Size = UDim2.new(1,-2,1,-2);drawings.outerline.Transparency = 1;drawings.outerline.ZIndex = 9998;drawings.outerline.AnchorPoint = Vector2.new(.5,.5);drawings.outerline.Position = UDim2.new(.5,0,.5,0);
	drawings.Name = Instance.new("TextLabel", gui);drawings.Name.AnchorPoint = Vector2.new(0.5, 0.5);drawings.Name.BackgroundTransparency = 1.000;drawings.Name.Size = UDim2.new(0, 50, 0, 20);drawings.Name.TextSize = 13;drawings.Name.ZIndex = 9999;drawings.Name.TextColor3 = Color3.fromRGB(255, 255, 255);drawings.Name.Font = Enum.Font.Code;drawings.Name.RichText = true;drawings.Name.Visible = false;
	drawings.Contaner = Instance.new("Frame", gui);drawings.Contaner.AnchorPoint = Vector2.new(0, 0);drawings.Contaner.Size = UDim2.new(0, 35, 1, 0);drawings.Contaner.BackgroundTransparency = 1;drawings.Contaner.Visible = false;
	drawings.Distance = Instance.new("TextLabel", drawings.Contaner);drawings.Distance.BackgroundTransparency = 1;drawings.Distance.Size = UDim2.new(1, 0, 0, 8);drawings.Distance.TextSize = 13;drawings.Distance.TextColor3 = Color3.fromRGB(255, 255, 255);drawings.Distance.Font = Enum.Font.Code;drawings.Distance.Visible = false;drawings.Distance.TextXAlignment = Enum.TextXAlignment.Left;Instance.new("UIStroke", drawings.Distance);local w = Instance.new("UIStroke", drawings.Distance) w.Transparency = 0.2
	drawings.Sleep = Instance.new("TextLabel", drawings.Contaner);drawings.Sleep.BackgroundTransparency = 1;drawings.Sleep.Size = UDim2.new(1, 0, 0, 8);drawings.Sleep.TextSize = 13;drawings.Sleep.TextColor3 = Color3.fromRGB(255, 255, 255);drawings.Sleep.Font = Enum.Font.Code;drawings.Sleep.Visible = false;drawings.Sleep.TextXAlignment = Enum.TextXAlignment.Left; local q = Instance.new("UIStroke", drawings.Sleep) q.Transparency = 0.2
	drawings.Tool = Instance.new("TextLabel", gui);drawings.Tool.AnchorPoint = Vector2.new(0.5, 0.5);drawings.Tool.BackgroundTransparency = 1.000;drawings.Tool.Size = UDim2.new(0, 50, 0, 20);drawings.Tool.TextSize = 13;drawings.Tool.ZIndex = 9999;drawings.Tool.TextColor3 = Color3.fromRGB(255, 255, 255);drawings.Tool.Font = Enum.Font.Code;drawings.Tool.RichText = true;drawings.Tool.Visible = false;
	
	drawings.info = playertable

	local idk1 = Instance.new("UIStroke", drawings.innerline);idk1.Color = Color3.fromRGB(255, 255, 255);idk1.Thickness = 1;idk1.LineJoinMode = Enum.LineJoinMode.Miter
	local idk2 = Instance.new("UIStroke", drawings.outerline);idk2.Color = Color3.fromRGB(0, 0, 0);idk2.Thickness = 3;idk2.LineJoinMode = Enum.LineJoinMode.Miter;idk2.Transparency = 0.2
	local idk3 = Instance.new("UIStroke", drawings.Name);idk3.Color = Color3.fromRGB(0, 0, 0);idk3.Thickness = 1;idk3.LineJoinMode = Enum.LineJoinMode.Miter;idk3.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual;idk3.Transparency = 0.2
	local idk4 = Instance.new("UIListLayout", drawings.Contaner);idk4.Padding = UDim.new(0, 4);
	local idk5 = Instance.new("UIStroke", drawings.Tool);idk5.Color = Color3.fromRGB(0, 0, 0);idk5.Thickness = 1;idk5.LineJoinMode = Enum.LineJoinMode.Miter;idk5.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual;idk5.Transparency = 0.2
	HasEsp[playertable.model] = drawings
end

function RemoveEsp(PlayerTable)
	if not PlayerTable or not PlayerTable.model then return end
	local esp = HasEsp[PlayerTable.model]
	if not esp then return end
	for _, v in pairs(esp) do
		if type(v) ~= "table" then
			v:Remove()
		end
	end
	cache[PlayerTable.model] = nil
	HasEsp[PlayerTable.model] = nil
end

function UpdateEsp()
	for i, v in pairs(HasEsp) do
		local char = i
		local sleeping = #((char:FindFirstChild("AnimationController") and char.AnimationController.Animator:GetPlayingAnimationTracks()) or {}) > 0 and char.AnimationController.Animator:GetPlayingAnimationTracks()[1].Animation.AnimationId == "rbxassetid://13280887764" or false
		if char and gui ~= nil and char ~= nil and char:IsDescendantOf(game:GetService("Workspace")) --[[and not sleeping]] then
			local Spos, on = Camera:WorldToScreenPoint(char.PrimaryPart.Position)
			local left, right, top, bottom, size = GetBoundingBox(char)
			
			local distance = (Camera.CFrame.Position - char.PrimaryPart.Position).Magnitude
			if on then
				v.Name.Visible = true
				v.innerline.Visible = true
				v.outerline.Visible = true
				v.Contaner.Visible = true
				v.Distance.Visible = true
				v.Sleep.Visible = true
				v.Tool.Visible = true
				v.innerline.Size = UDim2.new(0, right - left  , 0, bottom - top ) 
				v.innerline.Position = UDim2.new(0, left , 0, top )
				v.Name.Position = UDim2.new(0, v.innerline.Position.X.Offset+v.innerline.Size.X.Offset/2,0,v.innerline.Position.Y.Offset - v.Name.TextBounds.Y / 1.5)
				v.Contaner.Position = UDim2.new(0, v.innerline.Position.X.Offset + v.innerline.Size.X.Offset + (v.Contaner.Size.X.Offset/2) + 3, 0, v.innerline.Position.Y.Offset + 1)
				v.Tool.Position = UDim2.new(0, v.innerline.Position.X.Offset+v.innerline.Size.X.Offset/2, 0, v.innerline.Position.Y.Offset + v.innerline.Size.Y.Offset + v.Tool.TextBounds.Y / 1.5)
				local tool = v.info.equippeditem and v.info.equippeditem.type or " "
				v.Name.Text =  v.info.id
				v.Distance.Text = math.floor(distance) .. "s"
				v.Sleep.Text = sleeping and "Sleep" or "Awake"
				v.Tool.Text = tostring(tool)
			else
				v.Tool.Visible = false
				v.Sleep.Visible = false
				v.Distance.Visible = false
				v.Contaner.Visible = false
				v.Name.Visible = false
				v.innerline.Visible = false
				v.outerline.Visible = false
			end
		else
			RemoveEsp({ model = char })
		end
	end
end


RunService.Stepped:Connect(function()
	UpdateEsp()	
	for i, v in pairs(Players) do
		if not table.find(cache,v) then
			CreateEsp(v)
			table.insert(cache,v)
		end
	end
end)
